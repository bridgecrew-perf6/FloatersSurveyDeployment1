/**
 * chartjs-chart-geo
 * https://github.com/sgratzl/chartjs-chart-geo
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

import { CoreScaleOptions, Scale, CartesianScaleOptions, ChartArea, LinearScaleOptions, LinearScale, LogarithmicScaleOptions, LogarithmicScale, PointOptions, BarOptions, Element, VisualElement, Point, ChartTypeRegistry, DatasetController, ChartDataset, UpdateMode, ScriptableAndArrayOptions, ScriptableContext, ControllerDatasetOptions, CommonHoverOptions, Chart, ChartItem, ChartConfiguration, PointElement } from 'chart.js';
import { GeoProjection, GeoPath, GeoPermissibleObjects, ExtendedFeature, ExtendedFeatureCollection, GeoGeometryObjects, ExtendedGeometryCollection } from 'd3-geo';
import * as topojsonClient from 'topojson-client';
export { topojsonClient as topojson };

interface IProjectionScaleOptions extends CoreScaleOptions {
    /**
     * projection method used
     * @default albersUsa
     */
    projection: GeoProjection | 'azimuthalEqualArea' | 'azimuthalEquidistant' | 'gnomonic' | 'orthographic' | 'stereographic' | 'equalEarth' | 'albers' | 'albersUsa' | 'conicConformal' | 'conicEqualArea' | 'conicEquidistant' | 'equirectangular' | 'mercator' | 'transverseMercator' | 'naturalEarth1';
    projectionScale: number;
    projectionOffset: [number, number];
}
declare class ProjectionScale extends Scale<IProjectionScaleOptions> {
    readonly geoPath: GeoPath<any, GeoPermissibleObjects>;
    projection: GeoProjection;
    private outlineBounds;
    private oldChartBounds;
    constructor(cfg: any);
    init(options: IProjectionScaleOptions): void;
    computeBounds(outline: ExtendedFeature): void;
    computeBounds(outline: ExtendedFeatureCollection): void;
    computeBounds(outline: GeoGeometryObjects): void;
    computeBounds(outline: ExtendedGeometryCollection): void;
    updateBounds(): boolean;
    static id: string;
    static defaults: Partial<IProjectionScaleOptions>;
}
declare module 'chart.js' {
    interface ProjectionScaleTypeRegistry {
        projection: {
            options: IProjectionScaleOptions;
        };
    }
    interface ScaleTypeRegistry extends ProjectionScaleTypeRegistry {
    }
}

interface ILegendScaleOptions extends CartesianScaleOptions {
    /**
     * whether to render a color legend
     * @default false (for compatibility reasons)
     */
    display: boolean;
    /**
     * the property name that stores the value in the data elements
     * @default value
     */
    property: string;
    legend: {
        /**
         * location of the legend on the chart area
         * @default bottom-right
         */
        position: 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'top-right' | 'bottom-right' | 'bottom-left' | {
            x: number;
            y: number;
        };
        /**
         * alignment of the scale, e.g., `right` means that it is a vertical scale
         * with the ticks on the right side
         * @default right
         */
        align: 'left' | 'right' | 'top' | 'bottom';
        /**
         * length of the legend, i.e., for a horizontal scale the width
         * if a value < 1 is given, is it assume to be a ratio of the corresponding
         * chart area
         * @default 100
         */
        length: number;
        /**
         * how wide the scale is, i.e., for a horizontal scale the height
         * if a value < 1 is given, is it assume to be a ratio of the corresponding
         * chart area
         * @default 50
         */
        width: number;
        /**
         * how many pixels should be used for the color bar
         * @default 10
         */
        indicatorWidth: number;
        /**
         * margin pixels such that it doesn't stick to the edge of the chart
         * @default 8
         */
        margin: number | ChartArea;
    };
}
declare class LegendScale<O extends ILegendScaleOptions & LinearScaleOptions> extends LinearScale<O> {
    legendSize: {
        w: number;
        h: number;
    };
    init(options: O): void;
    parse(raw: any, index: number): number;
    isHorizontal(): boolean;
    protected _getNormalizedValue(v: number): number | null;
    update(maxWidth: number, maxHeight: number, margins: ChartArea): number;
    draw(chartArea: ChartArea): void;
    protected _drawIndicator(): void;
}
declare class LogarithmicLegendScale<O extends ILegendScaleOptions & LogarithmicScaleOptions> extends LogarithmicScale<O> {
    legendSize: {
        w: number;
        h: number;
    };
    init(options: O): void;
    parse(raw: any, index: number): number;
    isHorizontal(): boolean;
    protected _getNormalizedValue(v: number): number | null;
    update(maxWidth: number, maxHeight: number, margins: ChartArea): number;
    draw(chartArea: ChartArea): void;
    protected _drawIndicator(): void;
}

interface IColorScaleOptions extends ILegendScaleOptions {
    /**
     * color interpolation method which is either a function
     * converting a normalized value to string or a
     * well defined string of all the interpolation scales
     * from https://github.com/d3/d3-scale-chromatic.
     * e.g. interpolateBlues -> blues
     *
     * @default blues
     */
    interpolate: ((normalizedValue: number) => string) | 'blues' | 'brBG' | 'buGn' | 'buPu' | 'cividis' | 'cool' | 'cubehelixDefault' | 'gnBu' | 'greens' | 'greys' | 'inferno' | 'magma' | 'orRd' | 'oranges' | 'pRGn' | 'piYG' | 'plasma' | 'puBu' | 'puBuGn' | 'puOr' | 'puRd' | 'purples' | 'rainbow' | 'rdBu' | 'rdGy' | 'rdPu' | 'rdYlBu' | 'rdYlGn' | 'reds' | 'sinebow' | 'spectral' | 'turbo' | 'viridis' | 'warm' | 'ylGn' | 'ylGnBu' | 'ylOrBr' | 'ylOrRd';
    /**
     * color value to render for missing values
     * @default transparent
     */
    missing: string;
    /**
     * allows to split the colorscale in N quantized equal bins.
     * @default 0
     */
    quantize: number;
}
declare class ColorScale extends LegendScale<IColorScaleOptions & LinearScaleOptions> {
    private interpolate;
    init(options: IColorScaleOptions & LinearScaleOptions): void;
    getColorForValue(value: number): string;
    getColor(normalized: number): string;
    _drawIndicator(): void;
    static readonly id = "color";
    static readonly defaults: any;
}
declare class ColorLogarithmicScale extends LogarithmicLegendScale<IColorScaleOptions & LogarithmicScaleOptions> {
    private interpolate;
    init(options: IColorScaleOptions & LinearScaleOptions): void;
    getColorForValue(value: number): string;
    getColor(normalized: number): string;
    protected _drawIndicator(): void;
    static readonly id = "colorLogarithmic";
    static readonly defaults: any;
}
declare module 'chart.js' {
    interface ColorScaleTypeRegistry {
        color: {
            options: IColorScaleOptions & LinearScaleOptions;
        };
        colorLogarithmic: {
            options: IColorScaleOptions & LogarithmicScaleOptions;
        };
    }
    interface ScaleTypeRegistry extends ColorScaleTypeRegistry {
    }
}

interface ISizeScaleOptions extends ILegendScaleOptions {
    /**
     * whether to render a color legend
     * @default false (for compatibility reasons)
     */
    display: boolean;
    /**
     * radius range in pixel, the minimal data value will be mapped to the
     * first entry,  the maximal one to the second and a linear interpolation
     * for all values in between.
     *
     * @default [2, 20]
     */
    range: [number, number];
    /**
     * operation mode for the scale, area means that the area is linearly increasing whereas radius the radius is.
     * The area one is the default since it gives a better visual comparison of values
     * @default area
     */
    mode: 'radius' | 'area';
    /**
     * radius to render for missing values
     * @default 1
     */
    missing: number;
    /**
     * the property name that stores the value in the data elements
     * @default value
     */
    property: string;
    legend: {
        /**
         * location of the legend on the chart area
         * @default bottom-right
         */
        position: 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'top-right' | 'bottom-right';
        /**
         * alignment of the scale, e.g., `right` means that it is a vertical scale
         * with the ticks on the right side
         * @default bottom
         */
        align: 'left' | 'right' | 'top' | 'bottom';
        /**
         * length of the legend, i.e., for a horizontal scale the width
         * if a value < 1 is given, is it assume to be a ratio of the corresponding
         * chart area
         * @default 90
         */
        length: number;
        /**
         * how wide the scale is, i.e., for a horizontal scale the height
         * if a value < 1 is given, is it assume to be a ratio of the corresponding
         * chart area
         * @default 70
         */
        width: number;
        /**
         * how many pixels should be used for the color bar
         * @default 42
         */
        indicatorWidth: number;
        /**
         * margin pixels such that it doesn't stick to the edge of the chart
         * @default 8
         */
        margin: number;
    };
}
declare class SizeScale extends LegendScale<ISizeScaleOptions & LinearScaleOptions> {
    _model: PointOptions | null;
    getSizeForValue(value: number): number;
    getSizeImpl(normalized: number): number;
    _drawIndicator(): void;
    static readonly id = "size";
    static readonly defaults: any;
}
declare class SizeLogarithmicScale extends LogarithmicLegendScale<ISizeScaleOptions & LogarithmicScaleOptions> {
    _model: PointOptions | null;
    getSizeForValue(value: number): number;
    getSizeImpl(normalized: number): number;
    _drawIndicator(): void;
    static readonly id = "sizeLogarithmic";
    static readonly defaults: any;
}
declare module 'chart.js' {
    interface SizeScaleTypeRegistry {
        size: {
            options: ISizeScaleOptions & LinearScaleOptions;
        };
        sizeLogarithmic: {
            options: ISizeScaleOptions & LogarithmicScaleOptions;
        };
    }
    interface ScaleTypeRegistry extends SizeScaleTypeRegistry {
    }
}

interface IGeoFeatureOptions extends BarOptions {
    /**
     * background color for the outline
     * @default null
     */
    outlineBackgroundColor: string | null;
    /**
     * border color for the outline
     * @default defaultColor of Chart.js
     */
    outlineBorderColor: string;
    /**
     * border width for the outline
     * @default 0
     */
    outlineBorderWidth: number;
    /**
     * border color for the graticule
     * @default #CCCCCC
     */
    graticuleBorderColor: string;
    /**
     * border width for the graticule
     * @default 0
     */
    graticuleBorderWidth: string;
}
declare type Feature = any;
interface IGeoFeatureProps {
    x: number;
    y: number;
}
declare class GeoFeature extends Element<IGeoFeatureProps, IGeoFeatureOptions> implements VisualElement {
    cache?: {
        center?: Point;
        bounds?: {
            x: number;
            y: number;
            width: number;
            height: number;
            x2: number;
            y2: number;
        };
        canvasKey?: string;
        canvas?: HTMLCanvasElement;
    } | undefined;
    projectionScale: ProjectionScale;
    feature: Feature;
    inRange(mouseX: number, mouseY: number): boolean;
    inXRange(mouseX: number): boolean;
    inYRange(mouseY: number): boolean;
    getCenterPoint(): {
        x: number;
        y: number;
    };
    getBounds(): {
        x: number;
        y: number;
        x2: number;
        y2: number;
        width: number;
        height: number;
    };
    _drawInCache(doc: Document): void;
    _optionsToKey(): string;
    _drawImpl(ctx: CanvasRenderingContext2D): void;
    draw(ctx: CanvasRenderingContext2D): void;
    static id: string;
    static defaults: {
        outlineBackgroundColor: null;
        outlineBorderWidth: number;
        graticuleBorderColor: string;
        graticuleBorderWidth: number;
    };
    static defaultRoutes: {
        outlineBorderColor: string;
    };
}

declare class GeoController<TYPE extends keyof ChartTypeRegistry, TElement extends Element & VisualElement> extends DatasetController<TYPE, TElement, GeoFeature> {
    getGeoDataset(): ChartDataset<'choropleth' | 'bubbleMap'> & IGeoControllerDatasetOptions;
    getGeoOptions(): IGeoChartOptions;
    getProjectionScale(): ProjectionScale;
    linkScales(): void;
    showOutline(): IGeoChartOptions['showOutline'];
    clipMap(): IGeoChartOptions['clipMap'];
    getGraticule(): IGeoChartOptions['showGraticule'];
    update(mode: UpdateMode): void;
    resolveOutline(): any;
    showGraticule(): void;
    draw(): void;
}
interface IGeoChartOptions {
    /**
     * Outline used to scale and centralize the projection in the chart area.
     * By default a sphere is used
     * @default { type: 'Sphere" }
     */
    outline: any[];
    /**
     * option to render the outline in the background, see also the outline... styling option
     * @default false
     */
    showOutline: boolean;
    /**
     * option to render a graticule in the background, see also the outline... styling option
     * @default false
     */
    showGraticule: boolean | {
        stepMajor: [number, number];
        stepMinor: [number, number];
    };
    /**
     * option whether to clip the rendering to the chartArea of the graph
     * @default choropleth: true bubbleMap: 'outline+graticule'
     */
    clipMap: boolean | 'outline' | 'graticule' | 'outline+graticule' | 'items';
}
interface IGeoControllerDatasetOptions extends IGeoChartOptions, ScriptableAndArrayOptions<IGeoFeatureOptions, ScriptableContext<'choropleth' | 'bubbleMap'>> {
    xAxisID?: string;
    yAxisID?: string;
    rAxisID?: string;
    iAxisID?: string;
    vAxisID?: string;
}
interface IGeoDataPoint {
    feature: ExtendedFeature;
}

declare class ChoroplethController extends GeoController<'choropleth', GeoFeature> {
    initialize(): void;
    linkScales(): void;
    _getOtherScale(scale: Scale): Scale;
    parse(start: number, count: number): void;
    updateElements(elems: GeoFeature[], start: number, count: number, mode: UpdateMode): void;
    indexToColor(index: number): string;
    static readonly id = "choropleth";
    static readonly defaults: any;
    static readonly overrides: any;
}
interface IChoroplethControllerDatasetOptions extends ControllerDatasetOptions, IGeoChartOptions, ScriptableAndArrayOptions<IGeoFeatureOptions, ScriptableContext<'choropleth'>>, ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'choropleth'>> {
}
declare module 'chart.js' {
    interface ChartTypeRegistry {
        choropleth: {
            chartOptions: IGeoChartOptions;
            datasetOptions: IChoroplethControllerDatasetOptions;
            defaultDataPoint: IGeoDataPoint & {
                value: number;
            };
            parsedDataType: {
                r: number;
            };
            scales: keyof (ProjectionScaleTypeRegistry & ColorScaleTypeRegistry);
        };
    }
}
declare class ChoroplethChart<DATA extends unknown[] = IGeoDataPoint[], LABEL = string> extends Chart<'choropleth', DATA, LABEL> {
    static id: string;
    constructor(item: ChartItem, config: Omit<ChartConfiguration<'choropleth', DATA, LABEL>, 'type'>);
}

declare class BubbleMapController extends GeoController<'bubbleMap', PointElement> {
    initialize(): void;
    linkScales(): void;
    _getOtherScale(scale: Scale): Scale;
    parse(start: number, count: number): void;
    updateElements(elems: PointElement[], start: number, count: number, mode: UpdateMode): void;
    indexToRadius(index: number): number;
    static readonly id = "bubbleMap";
    static readonly defaults: any;
    static readonly overrides: any;
}
interface IBubbleMapDataPoint {
    longitude: number;
    latitude: number;
    x?: number;
    y?: number;
    value: number;
}
interface IBubbleMapControllerDatasetOptions extends ControllerDatasetOptions, IGeoChartOptions, ScriptableAndArrayOptions<IGeoFeatureOptions, ScriptableContext<'bubbleMap'>>, ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'bubbleMap'>> {
}
declare module 'chart.js' {
    interface ChartTypeRegistry {
        bubbleMap: {
            chartOptions: IGeoChartOptions;
            datasetOptions: IBubbleMapControllerDatasetOptions;
            defaultDataPoint: IBubbleMapDataPoint;
            parsedDataType: {
                r: number;
                x: number;
                y: number;
            };
            scales: keyof (ProjectionScaleTypeRegistry & SizeScaleTypeRegistry);
        };
    }
}
declare class BubbleMapChart<DATA extends unknown[] = IBubbleMapDataPoint[], LABEL = string> extends Chart<'bubbleMap', DATA, LABEL> {
    static id: string;
    constructor(item: ChartItem, config: Omit<ChartConfiguration<'bubbleMap', DATA, LABEL>, 'type'>);
}

export { BubbleMapChart, BubbleMapController, ChoroplethChart, ChoroplethController, ColorLogarithmicScale, ColorScale, Feature, GeoController, GeoFeature, IBubbleMapControllerDatasetOptions, IBubbleMapDataPoint, IChoroplethControllerDatasetOptions, IColorScaleOptions, IGeoChartOptions, IGeoControllerDatasetOptions, IGeoDataPoint, IGeoFeatureOptions, IGeoFeatureProps, IProjectionScaleOptions, ISizeScaleOptions, ProjectionScale, SizeLogarithmicScale, SizeScale };
//# sourceMappingURL=index.d.ts.map
